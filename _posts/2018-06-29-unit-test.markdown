---
layout: post
title:  "单元测试思考"
date:   2018-06-29
categories: post
---

长期以来基本是围绕遗留项目开发业务为主，单元测试很难实行。分析原因大致是下面几个：

1. 时间紧，来不及写
2. 模块纠缠不清，写不出
3. 依赖好多环境，测试很难跑

终于在一次新项目中强迫自己实行后，有了一些总结。

测试难写的原因在于写代码时没有为测试考虑，更准确的说是没有设计好你写的代码，设计良好的代码一定是方便测试的。所以，如果有心实行单元测试的同学，记住，写的时候考虑一点，能写出对应的测试吗？（这应该也是TDD出现的原因吧，测试先行强制了代码的可测试性）

那么怎么围绕测试去设计代码呢？我的一个思路是`起名字`，因为当你给一堆代码命名之后，这段代码就有了定义，他的作用是什么，需要什么入参，会返回什么都是趋于清晰的。着手一项开发任务时，你要做的是拆解这个任务到可以由各种`名字`组合出来，然后验证各个拆出来的`名字`是不是方便写测试，如果还是不方便，继续拆解这个`名字`。

当每个配上了足够多测试的名字组合后，整体的质量也是更有保障的。

实践中还会碰到环境依赖问题，一个典型的例子就是数据库。这个根据实际情况大致有三种方式应对：

1. mock数据库。
2. 拆出来，可以脱离操作库单独测。如果测试点不在数据库上，推荐使用这个方式。
3. 人为构造适合测试的数据库环境。比如执行前初始化一些数据，执行完后库回滚，很多测试框架都支持。

举个例子，一个借贷系统中的还款功能，原始版本是计算和更新库黏在一起的，因为校验点在更新后的每期还款数据，所以只能选择方式3，不同的测试用例需要初始化不同的数据，查库校验，然后回滚。

```
还款(借款ID, 控制参数) {
    每期还款数据[] = 查询未还清记录()
    组合还款数据和参数计算并更新库()
}
```

另个思路结合了`起名字`法和方法2，拆出`还款计算器`，还款计算器内只是纯计算，测试时不依赖运行的数据库，构造不同情况的每期还款数据做为入参，校验返回值即可。而`还款`方法本身则只要保证更新库的正确即可，不同情况还款的多样性转嫁到了方便测试的`还款计算器`上了。

```
还款(借款ID, 控制参数) {
    还款计算器()
    更新库()
}

还款计算器(每期还款数据[], 控制参数) {
    还款后每期还款数据[] = 组合还款数据和控制参数计算()
    返回 还款后每期还款数据[]
}
```
